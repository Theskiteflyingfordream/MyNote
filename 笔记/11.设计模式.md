## 单例模式

确保一个类只有一个实例，并提供该实例的全局访问点;

饿汉模式；

懒汉模式；

volatile+双重校验锁；



## 工厂模式

简单工厂模式：

将创建类的细节（比如一些判断逻辑），放到了工厂类里边，它根据传入的条件选择实例化对应的类，从而实现了客户端与具体产品实例化的解耦。（使用反射削除判断逻辑，进一步使用配置文件解耦）

应用场景：BeanFactory

工厂方法模式：

在工厂模式中，由于判断逻辑存在于工厂类里，新增类的时候，需要修改工厂类的代码。因此就有了工厂方法模式，它的大概思想就是，定义一个用于创建对象的接口，让子类决定实例化哪一个类。但是这样就会出现另一个问题，原本在工厂类的判断逻辑，搬到了客户端代码，加功能需要修改客户端。

应用场景：FactoryBean

抽象工厂模式：

抽象工厂模式创建的是对象家族，这些对象是相关的。和工厂模式一样，它的对象的真正实例化，也是延迟到了子类进行。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。它的缺点是更换功能，需要修改客户端代码。

可以使用简单工厂模式优化

https://blog.51cto.com/u_11142439/3065071



## 观察者模式

定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。它实现了被观察者与观察者的解耦，被观察者不需要知道观察者的具体实现，观察者也不需要感知被观察者的存在。

应用场景：SpringMVC的事件监听机制

## 模板方法

在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤。提高了代码的可重用性。

应用场景：AQS

## 代理模式

代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

应用场景：静态代理；动态代理

## 责任链模式

在多个请求处理者的情况下，解除了请求发送者与请求处理者的耦合，双方都没有对方的明确信息；而且链中的对象也不知道链的结构，每个对象仅维持后继的引用。缺点是可能某一个请求处理者抛异常了，后续的就没法处理。



## 适配器模式

将一个类的接口转换成客户希望的另一个接口，使得原本不兼容的接口可以一起工作。

应用场景：FutureTask类